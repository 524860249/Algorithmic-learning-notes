# 什么是贪心算法
贪心算法又称为贪婪算法，意为在对问题求解时，总是在当前做出最优的选择，也就是说不从整体最优上加以考虑，他所做的在某种意义上是局部最优解。  
贪心算法得到的结果可能不是全局最优解，而是全局最优解的近似解。

### 算法基本要素

#### 贪心选择
贪心选择是指所求的问题的全局最优解可由一系列局部最优的选择，即贪心选择达到   
应用同一种规则，将原来的问题变为相似的但规模更小子问题，然后每一步都都是当前最佳的选择

#### 最优子结构
当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。

### 算法攻略
>1.算法策略   
根据不同的要求选取贪心策略，选择当前看上去最优的方案   
<font color="red">
比如从一堆古董中挑选10个最好的古董，你认为古董贵的最好，那么你就每次都从一堆古董中挑选最贵的那个，作为局部最优。如果你认为古董时间久的最好，那么你每次都从一堆古董中挑选时间最久的。   
根据不同求解的目的，贪心策略的选择也不同   
</font>
>2.局部最优   
根据贪心策略，每一步都得到局部最优解  
<font color="red"> 
比如第一次挑到最大的古董放起来，记录为a1，第二次挑到最大的放起来记录为a2,以此类推   
</font>
>3.全局最优   
汇总所有的局部最优，即可得到全局最优   
<font color="red"> 
每次挑选最好的古董都放在一起，那么这10次挑选的古董就是这一堆古董中最好的
</font>

### 加勒比海盗-最优装载问题
加勒比海盗抢劫了一艘拉有古董的船，没见古董都价值不菲，一旦打碎久失去了价值，海盗想带走古董，但海盗船的载重固定，不能全部带走，所以海盗想带着更多数量的古董。
#### 算法设计
>1 当海盗船载重固定为W时，古董的重量越小，船上可装载的古董数量就越多，只要依次拿重量最小的古董，直到不能再装为止   
>2 把所有的古董按照重量从小到大排序，然后根据贪心算法，每次只拿重量最小的古董，直到不能再装为止即可得到最优的装载方案   
#### 程序实现   
	#include <stdio.h>
	#include <iostream>
	#include <algorithm>
	using namespace std;

	const int N = 10000;
	int main()
	{
	    double weights[N];  //记录所有古董的重量
	    double loadNum; //海盗船的载重
	    int antiqueNum; //古董的数量
	    cout << "请输入海盗船的载重" << endl;
	    cin >> loadNum;
	    cout << "请输入古董的个数" << endl;
	    cin >> antiqueNum;
	    for (int i = 0; i < antiqueNum; i++) {
	        cout << "请输入第" << i + 1 << "个古董的重量" << endl;
	        cin >> weights[i];
	    }
	    //古董重量排序，从小到大
	    sort(weights, weights + antiqueNum);
	    //记录已经选择的古董的重量
	    double temp = 0.0;
	    //记录已经选择的古董的数量
	    int takeNum = 0;
	    for (int i = 0; i < antiqueNum; i++) {
	        if (temp + weights[i] > loadNum) {
	            break;
	        }
	        temp += weights[i];
	        takeNum += 1;
	    }
	    cout << "可以装载" << takeNum << "个古董，总重量共" << temp << endl;
	    return 0;
	}
#### 运行结果
	请输入海盗船的载重
	100
	请输入古董的个数
	10
	请输入第1个古董的重量
	1
	请输入第2个古董的重量
	3
	请输入第3个古董的重量
	4
	请输入第4个古董的重量
	12
	请输入第5个古董的重量
	23
	请输入第6个古董的重量
	34
	请输入第7个古董的重量
	45
	请输入第8个古董的重量
	56
	请输入第9个古董的重量
	67
	请输入第10个古董的重量
	78
	可以装载6个古董，总重量共77

### 阿里巴巴与四十大盗-背包问题
阿里巴巴赶着小毛驴发现了四十大盗的宝库，宝库中有着无数的金银财宝，阿里巴巴想将财宝每样带回去一个，给乡亲们看看，如果太重，就用锤子砸开。但是毛驴的运输能力有限，阿里巴巴通过什么方式可以运走最大价值的财宝？
#### 算法设计
>1 数据结构的设计和数据初始化，将n种宝物的重量和价值保存在结构体(包含重量、价格、性价比三个属性)，同时求出每种宝物的性价比保存在结构体中，然后按照性价比由高到低排序。   
>2 按照贪心策略，每次从宝物中找出性价比最高的宝物，连同已经选择的宝物一起计算重量，判断如果重量小于驴子可承受的重量，则继续选择宝物，如果当前重量大于驴子则将新选择的宝物拆分出刚好驴子可以负载的重量。   

|宝物|重量|价值|
|  ----  | ----  | ----  |
|1|5|25|
|2|2|7|
|3|6|9|
|4|3|6|
|5|8|20|
|6|7|7|
|7|5|7|
|8|4|16|
|9|6|18|

计算宝物的性价比，按照性价比从高到低排序

|宝物|重量|价值|性价比|	|宝物|重量|价值|性价比|
|  ----  | ----  | ----  | ----  | ----  |  ----  | ----  | ----  | ----  |
|1|5|25|5|	|1|5|25|5|
|2|2|7|3.5|	|8|4|16|4|
|3|6|9|1.5|	|2|2|7|3.5|
|4|3|6|2|	|9|6|18|3|
|5|8|20|2.5|	|5|8|20|2.5|
|6|7|7|1|	|4|3|6|2|
|7|5|7|1.4|	|3|6|9|1.5|
|8|4|16|4|	|7|5|7|1.4|
|9|6|18|3|	|6|7|7|1|

假如毛驴的运载能力为30，按照贪心策略每次选择性价比最高的宝物让驴子运载：   
第一次选择宝物1，驴子的运载重量为5，总价值为25   
第二次选择宝物8，驴子的运载重量为9，总价值为41   
第三次选择宝物2，驴子的运载重量为11，总价值为48   
第四次选择宝物9，驴子的运载重量为17，总价值为66   
第五次选择宝物5，驴子的运载重量为25，总价值为86   
第六次选择宝物4，驴子的运载重量为28，总价值为92   
第七次选择宝物3，驴子的运载重量为34，此时已经超过驴子的运载能力，那么阿里巴巴就需要将宝物3拆分，拆分出重量为2的部分，此部分价值为9*(2/6) = 3。总价值为95   
此时，驴子运载了宝物1,8,2,9,5,4,3，那么最优解即为（1,8,2,9,5,4,3），驴子运载的宝物的最大价值为95

#### 程序实现
	#include <stdio.h>
	#include <iostream>
	#include <algorithm>
	using namespace std;

	const int N = 10000;

	struct treasure{
	    double weight;
	    double price;
	    double quality;
	} t[N];

	bool cmp(treasure first,treasure second)
	{
	    return first.quality > second.quality;
	}

	int main()
	{
	    int treasureNum;  //宝物的数量
	    double loadNum;    //驴子的画运载能力
	    
	    cout << "请输入驴子的载重能力" << endl;
	    cin >> loadNum;
	    cout << "请输入宝物的数量" << endl;
	    cin >> treasureNum;
	    for (int i = 0; i < treasureNum; i++) {
	        cout << "请输入第" << i + 1 << "个宝物的重量及价格，以空格分隔：" << endl;
	        cin >> t[i].weight >> t[i].price;
	        t[i].quality = t[i].price / t[i].weight;
	    }
	    
	    sort(t, t + treasureNum, cmp);
	    for (int i = 0; i < treasureNum; i++) {
	        cout << "重量:" << t[i].weight << " 价格:" << t[i].price << " 性价比:" << t[i].quality << endl;
	    }
	    
	    double totalValue = 0.0;
	    for (int i = 0; i < treasureNum; i++) {
	        if (loadNum > t[i].weight) {
	            totalValue += t[i].price;
	            loadNum -= t[i].weight;
	            cout << "宝物重量:" << t[i].weight << " 宝物价格：" << t[i].price << " 宝物性价比:" << t[i].quality << " 已经装载重量:" << totalValue << " 剩余空间:" << loadNum <<  endl;
	        } else {
	            totalValue += t[i].price * (loadNum / t[i].weight);
	            cout << "宝物重量:" << t[i].weight << " 宝物价格：" << t[i].price << " 宝物性价比:" << t[i].quality << " 已经装载重量:" << totalValue << " 剩余空间:" << loadNum << " 拆分当前宝物，取重量为" << loadNum << "的，其价值为" << t[i].price * (loadNum / t[i].weight) << endl;
	            break;
	        }
	    }
	    cout << "阿里巴巴运走的财宝的总价值为" << totalValue << endl;
	    return 0;
	}
#### 运行结果
	请输入驴子的载重能力   
	30   
	请输入的数量   
	9   
	请输入第1个宝物的重量及价格，以空格分隔：   
	5 25   
	请输入第2个宝物的重量及价格，以空格分隔：   
	2 7   
	请输入第3个宝物的重量及价格，以空格分隔：   
	6 9   
	请输入第4个宝物的重量及价格，以空格分隔：   
	3 6   
	请输入第5个宝物的重量及价格，以空格分隔：   
	8 20   
	请输入第6个宝物的重量及价格，以空格分隔：   
	7 7   
	请输入第7个宝物的重量及价格，以空格分隔：   
	5 7   
	请输入第8个宝物的重量及价格，以空格分隔：   
	4 16   
	请输入第9个宝物的重量及价格，以空格分隔：   
	6 18   
	重量:5 价格:25 性价比:5   
	重量:4 价格:16 性价比:4   
	重量:2 价格:7 性价比:3.5   
	重量:6 价格:18 性价比:3   
	重量:8 价格:20 性价比:2.5   
	重量:3 价格:6 性价比:2   
	重量:6 价格:9 性价比:1.5   
	重量:5 价格:7 性价比:1.4   
	重量:7 价格:7 性价比:1   
	宝物重量:5 宝物价格：25 宝物性价比:5 已经装载重量:25 剩余空间:25   
	宝物重量:4 宝物价格：16 宝物性价比:4 已经装载重量:41 剩余空间:21   
	宝物重量:2 宝物价格：7 宝物性价比:3.5 已经装载重量:48 剩余空间:19   
	宝物重量:6 宝物价格：18 宝物性价比:3 已经装载重量:66 剩余空间:13   
	宝物重量:8 宝物价格：20 宝物性价比:2.5 已经装载重量:86 剩余空间:5   
	宝物重量:3 宝物价格：6 宝物性价比:2 已经装载重量:92 剩余空间:2   
	宝物重量:6 宝物价格：9 宝物性价比:1.5 已经装载重量:95 剩余空间:2 拆分当前宝物，取重量为2的，其价值为3   
	阿里巴巴运走的财宝的总价值为95    

#### 算法分析
上面的算法中的宝物可以做拆分，那么我们就可以用贪心算法，从局部最优解中得到全局最优解。但是在很多情况下物体无法拆分，此时再使用贪心算法可能就无法得到最优解，如

|宝物|重量|价值|性价比|
|  ----  | ----  | ----  | ----  |
|1|3|15|5|
|2|4|16|4|
|3|6|18|3|
|4|10|25|2.5|
|5|7|14|2|

如果驴子可运载的重量为10，那么使用贪心算法我们选择的宝物为1和2，总价值为31。但如果我们选择的是3和4 ，总价值将会变为34。显然此处使用贪心算法就无法得到全局最优解。   
那么针对这俩中物品是否可拆分可分为俩个问题，物体可拆分被称为**背包问题**，不可拆分则被称为**0-1背包问题**   
显然在不可拆分的问题中，全局最优解并非可以通过局部最优解获得（不具有贪心选择性质），但是如果问题中不需要全局最优解，而需要一个接近全局最优解近似解，则依然可使用贪心算法。   




























