# 动态规划
我们在分治法中学习的是将原问题分解为若干个规模较小，形式相同的子问题，子问题之间相互独立，通过求解子问题的解，而后合并子问题的解得到原问题的解。   
但是如果子问题有重叠，不能相互独立，那么如果使用了分治算法，就会重复计算子问题，导致效率及其低下。此时我们就需要动态规划。   
动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干个子问题，自顶向下求解各个子问题，合并子问题求解。动态规划是把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存入表格，再求解大的子问题时，直接从表格中查询小的子问题求解，避免重复计算，从而提高算法效率。

### 动态规划算法要素：
	1、最优子结构。最优子结构性质是指问题的最优解包含子问题的最优解。最优子结构是使用动态规划的基本条件，如果不满足最优子结构，就不可以使用动态规划。
	2、子问题重叠。子问题重叠是在求解的过程中，有大量子问题是重叠的，所以在求解过程中，将子问题的解存储，一遍求解更大问题时直接使用，避免重复计算，提高效率


### 最长公共子序列
如果我们有俩个序列X={x1,x2,x3,x4,x5,x6.....xn}，Y={y1,y2,y3,y4,y5......yn}，需要从X序列中和Y序列中找出一个最长的公共子序列。

#### 算法设计
> 1. 从俩个字符串中找出一个最长的公共子序列，需要对俩个字符串中的左右字符做逐一比对，最终按照顺序找出一个最长的公共子序列。看似优点像分治法，需要将大问题拆分若干个小问题，实则不然，拆分后的子问题彼此之间相互嵌套，所以并不能使用分治法来解决问题。
> 2. 假设俩个字符串str1和str2长度分别为i和j，则使用一个二维数组来记录最长公共序列的长度，在运算结束后，通过倒推的方式将最长子序列推到出来。声明二维数组c[][];
> 3. 初始化二维数组的第一行和第一列均为0
> 4. 循环处理
>> a. i=1，则str1[0]与str2[j-1]比较，其中j=1，2，3，4，5......j-1.  
>> b. 如果str1[0] = str2[j-1]，则c[i][j] = c[i-1][j-1] + 1
>> c. 如果str1[0] ≠ str2[j-1]，则当前公共序列的最长度为c[i-1][j]与c[i][j-1]俩者中较大的值，如：c[i-1][j] >= c[i][j-1]，则c[i][j] = c[i-1][j]。
>> d. i=2，则str1[1]与str2[j-1]比较，其中j=1，2，3，4，5......j-1.  
>> e. 重复b、c步骤
>> f. 直至俩个字符串中所有字符比较完毕，其中c[i][j]中的值即为俩个序列最长公共子序列的长度。
>> g. 通过我们求出的二维数组中的所有值，按照b、c逻辑倒推，求出最长公共子序列。

#### 程序实现
	#include <iostream>
	#include <cstring>

	using namespace std;

	const int N = 100;
	int c[N][N];
	char str1[N],str2[N];
	int len1,len2;

	void LCSL()
	{
	    int i,j;
	    for (i = 1; i <= len1; i++) {
	        for (j = 1; j <= len2; j++) {
	            if (str1[i - 1] == str2[j - 1]) {
	                c[i][j] = c[i-1][j-1] + 1;
	            } else {
	                if (c[i][j -1] >= c[i-1][j]) {
	                    c[i][j] = c[i][j-1];
	                }else{
	                    c[i][j] = c[i-1][j];
	                }
	            }
	        }
	    }
	}

	void print(int i,int j)
	{
	    if (i < 0 || j < 0) {
	        return;
	    }
	    if (c[i][j] == c[i-1][j-1]) {
	        print(i - 1, j - 1);
	        return;
	    }
	    if (c[i][j-1] == c[i-1][j] && c[i-1][j-1] == c[i][j-1]) {
	        print(i - 1, j - 1);
	        cout << str1[i - 1];
	        return;
	    }
	    if (c[i][j-1] >= c[i-1][j]) {
	        print(i,j-1);
	    }
	    if (c[i-1][j] > c[i][j-1]) {
	        print(i-1,j);
	    }
	}


	int main()
	{
	    int i,j;
	    cout << "输入第一个字符串S1" << endl;
	    cin >> str1;
	    cout << "输入第二个字符串S2" << endl;;
	    cin >> str2;
	    
	    len1 = strlen(str1);
	    len2 = strlen(str2);
	    
	    for (i = 0; i <= len1; i++) {
	        c[i][0] = 0;
	    }
	    for (j = 0;j <= len2; j++) {
	        c[0][j] = 0;
	    }
	    LCSL();
	    
	    cout << "    ";
	    for (j = 0; j <= len2; j++) {
	        cout << str2[j] << " ";
	    }
	    cout << endl;
	    for (i = 0; i <= len1;i++) {
	        if (i > 0) {
	            cout << str1[i - 1] << " ";
	        }else{
	            cout << "  ";
	        }
	        
	        for (j = 0; j <= len2; j++) {
	            cout << c[i][j] << " ";
	        }
	        cout << endl;
	    }
	    
	    cout << "-------------------" << endl;
	    
	    print(len1,len2);
	    cout << endl;
	    return 0;
	}

#### 运行结果
```
输入第一个字符串S1
abcdefhtc
输入第二个字符串S2
acdeftbc
    a c d e f t b c 
  0 0 0 0 0 0 0 0 0 
a 0 1 1 1 1 1 1 1 1 
b 0 1 1 1 1 1 1 2 2 
c 0 1 2 2 2 2 2 2 3 
d 0 1 2 3 3 3 3 3 3 
e 0 1 2 3 4 4 4 4 4 
f 0 1 2 3 4 5 5 5 5 
h 0 1 2 3 4 5 5 5 5 
t 0 1 2 3 4 5 6 6 6 
c 0 1 2 3 4 5 6 6 7 
-------------------
acdeftc
```
#### 算法分析
> 1. 我们打印出了用以记录最长公共子序列长度的二维表，对照二维表我们可以反向分析算法设计中的诸多问题。   
> 2. 二维表的列的下标对应str1数组的下标，行的下标对应str2数组的下标。   
> 3. 使用str1中的每个字符与str2的字符比对，如str1中的a与str2中比对，第一个字符相等，所以str1中的a同str2中的a的公共子序列的长度为1.继续与str2的其他字符比对，知道完全比对完，最终c[1][j]=1。表示字符a与str2的公共子序列的长度为1。
> 4. 我们继续用str1的第二个字符b，与str2比对，在j=7时于str2的b相等，所以str1中的ab与str2的公共子序列的长度为2。
> 5. 同理，我们继续用str1的第三个字符c，与str2比对，在j=2时与str2的c相等，所以str中的abc与str2中的ac公共子序列的长度为2。直至j=8时，str1中的abc与str2字符串的公共子序列的长度为3
> 6. 重复执行，直至str1中的所有字符与str2比对完毕，则在c[i][j]处保存的即为俩个字符串的公共子序列的长度。
> 7. 通过二维数据表，算法设计中的b、c俩个数据处理方式的逆推，即可求出最长公共子序列

### 编辑距离
我们经常会听到DNA亲子鉴定，但是具体是如何鉴定的我们完全不明白什么原理，人类的DBA由4个基本字母{A,C,G,T}构成，包含30多亿个字符。我们经常在电视上看到DNA鉴定报告由相似度99.99%，哪怕是0.01%也意味着300万个位置不同，那么面对如此庞大的数据量，如何判断俩个基因的相似度呢？生物学给出一种编辑距离的概念。
如何理解编辑距离呢？
```
	在信息论、语言学和计算领域，Levenshtein Distance 是用来度量两个序列相似程度的指标。
	通俗地来讲，编辑距离指的是在两个单词w1,w2之间，由其中一个单词w1转换为另一个单词w2所需要的最少单字符编辑操作次数。
	这里定义了编辑操作有三种：插入、删除、替换
	如：sister和system这俩个单词，由sister转换为system需要的最少单字符编辑操作
		i替换为y
		r替换为m
	一共俩次操作，所有sister和system的编辑距离为2.
	
```
#### 算法分析
> 1. 因需要比对俩个字符str1和str2，我们用一个二维数组来记录编辑距离dis[][]，其二维数组的行和列为len(str2)+1、列为len(str1)+1，如：数组的大小为dis[i][j]，其中i=len(str1)+1 ，j=len(str2)+1
> 2. 初始化这个二维数组，行的每个数值为0，1，2，3......len(str2)，列的数值为0，1，2，3....len(str1)，行和列分别对应俩个字符，如： 

| | |s|y|s|t|e|m|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
| |0|1|2|3|4|5|6|
|s|1| | | | | | |
|i|2| | | | | | |
|s|3| | | | | | |
|t|4| | | | | | |
|e|5| | | | | | |
|r|6| | | | | | |

> 当i=1时，与str1中的第一个字符s与str2做一次比对，如果字符相等，则dis[i][j]=0,否则dis[i][j]=1，按照递归公式d[i][j] = min{dis[i-1][j]+1,dis[i][j-1]+1,dis[i-1][j-1]+dis[i][j]}，
那么当str1的第一个字符，与str2中的每个字符比对时，得到的数值为，0，1，2，3，4，5。如：

| | |s|y|s|t|e|m|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
| |0|1|2|3|4|5|6|
|s|1|0|1|2|3|4|5|
|i|2| | | | | | |
|s|3| | | | | | |
|t|4| | | | | | |
|e|5| | | | | | |
|r|6| | | | | | |

> 当i=2时，与str2中的第二个字符i与str2座一次比对，则得到的对应的数值为：1，1，2，3，4，5。继而用str1中的每个字符进行比对。

| | |s|y|s|t|e|m|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
| |0|1|2|3|4|5|6|
|s|1|0|1|2|3|4|5|
|i|2|1|1|2|3|4|5|
|s|3|2|2|1|2|3|4|
|t|4|3|3|2|1|2|3|
|e|5|4|4|3|2|1|2|
|r|6|5|5|4|3|2|2|

> 运算完毕后，dis[len1][len2]值为俩个字符的编辑距离   

#### 程序实现
	#include <iostream>
	#include <cstring>

	using namespace std;

	const int N = 1000;

	char str1[N],str2[N];
	int dis[N][N];

	int min(int a,int b)
	{
	    return a>b?b:a;
	}

	int editDistance(char *str1,char *str2)
	{
	    int len1 = strlen(str1);
	    int len2 = strlen(str2);
	    for (int i = 0; i <= len1; i++) {
	        dis[i][0] = i;
	    }
	    cout << endl << "   " ;
	    for (int j = 0; j <= len2; j++) {
	        cout << " " << str2[j];
	    }
	    cout << endl << " " ;
	    for (int j = 0; j <= len2; j++) {
	        dis[0][j] = j;
	        cout << " " << dis[0][j];
	    }
	    for (int i = 1; i <= len1; i++) {
	        for (int j = 1; j <= len2; j++) {
	            int dif;
	            if (str1[i-1] == str2[j-1]) {
	                dif = 0;
	            } else {
	                dif = 1;
	            }
	            int temp = min(dis[i][j-1] + 1,dis[i-1][j] + 1);
	            dis[i][j] = min(temp,dis[i-1][j-1] + dif);
	        }
	        cout << endl << str1[i-1] << " " << i << " ";
	        for(int j = 1;j<=len2;j++){
	            cout << dis[i][j] << " ";
	        }
	    }
	    return dis[len1][len2];
	}
	int main ()
	{
	    cout << "输入第一个字符串" << endl;
	    cin >> str1;
	    cout << "输入第二个字符串" << endl;
	    cin >> str2;
	    int distance = editDistance(str1, str2);
	    cout << endl << str1 << "和" << str2 << "的编辑距离是：" << distance << endl;
	    return 0;
	}
#### 运行结果1
	输入第一个字符串
	sistem
	输入第二个字符串
	system
	    s y s t e m 
	  0 1 2 3 4 5 6
	s 1 0 1 2 3 4 5 
	i 2 1 1 2 3 4 5 
	s 3 2 2 1 2 3 4 
	t 4 3 3 2 1 2 3 
	e 5 4 4 3 2 1 2 
	r 6 5 5 4 3 2 2 
	sistem和system的编辑距离是：2

#### 运行结果2
	输入第一个字符串
	annie
	输入第二个字符串
	anyone
	    a n y o n e 
	  0 1 2 3 4 5 6
	a 1 0 1 2 3 4 5 
	n 2 1 0 1 2 3 4 
	n 3 2 1 1 2 2 3 
	i 4 3 2 2 2 3 3 
	e 5 4 3 3 3 3 3 
	annie和anyone的编辑距离是：3

### 游艇租凭
游艇俱乐部在长江上设置了N个游艇出租站，游艇可以在这些租用游艇，在下游的任何一个点归还游艇，每一站的游艇租金固定，现在要求出游艇出租站1到出租站n所需的最少的租金。
```
从起点到终点，每一站都有不同的租金，那么从起点到终点的最优解是否包含1～n的最优解，答案是肯定的。
如我们在第K个站点停靠会得到最优解，那么我们就可以将问题分为俩部分1~k、k～N，其中俩个子问题必然包含子结构的最优解，那么该问题具有最优子结构的性质。
从j=i开始，如果j=i，则v[i][j]=0
j=i+1,相差一个站，则v[i][j]=r[i][j]
j>i+1,相差俩个站以上，假设在k站点下，则v[i][j]=min{v[i][k]+v[k][j],r[i][j]}。其中i<k<j，随着k的变化计算并存储v[i][j]的最优解。
逐个计算3个站点、4个站点、5个站点......n个站点的最少租金
根据最终结果，逆向求出最优解。
```

#### 算法分析
> 定义一个二维数组r[i][j]记录每个站点到其他站点的租金，如站点数量为n，则定二维数组r[i][j]，其中i和j大小均为n+1   
> 定义一个二维数组v[i][j]记录各个子问题的最优解，初始化v[i][j]=r[i][j]   
> 定义一个二维数组s[i][j]记录每个区间最优的停靠站点，初始化所有数据为0   

|站点|1|2|3|4|5|6|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|1|0|2|6|9|15|20| 
|2|0|0|3|5|11|18|
|3|0|0|0|3|6|12|
|4|0|0|0|0|5|8|
|5|0|0|0|0|0|6|
|6|0|0|0|0|0|0|

列表为r和m，明确的定义了每个站点到下游站点的租金，那么接下来我们就要计算出每3个站点、4个站点、5个站点......n个站点的所需的最少租金，替换v中的数据。   

	依次计算3个站点最优解，其中i，i+1，j=i+2，将最优解结果存储至v[i][j]，i取值范围（1～n-2）   
	如每次计算三个站点，则需要计算的站点区间为1~3，2～4，3～5，4～6   
	i=1，j=3。停靠站点为2时。其中v[1][2]+v[2][3]=5，原v[1][3]=6。取最优解，则v[1][3]=5。1～3的最优停靠站点为2，则设置s[1][3]=2
	i=2，j=4。停靠站点为3时，其中v[2][3]+v[3][4]=6，原v[2][4]=5。无需更新v[2][4]   
	i=3，j=5。停靠站点为4时，其中v[3][4]+v[4][5]=8，原v[3][5]=6，无需更新v[3][5]   
	i=4，j=6。停靠站点为5时，其中v[4][5]+v[5][6]=11，原v[4][6]=8，无需更新v[4][6]   

当按照三个站点计算完毕，二维数组v的结果为   

|站点|1|2|3|4|5|6|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|1|0|2|5|9|15|20| 
|2|0|0|3|5|11|18|
|3|0|0|0|3|6|12|
|4|0|0|0|0|5|8|
|5|0|0|0|0|0|6|
|6|0|0|0|0|0|0|

	依次计算4个站点的最优解，其中i，i+1，i+2，j=i+3，将最优解存储至v[i][j]，i取之范围(1~n-3)   
	如果每次计算四个站点，则
	i=1，j=4时，停靠站点为2时，其中v[1][2]+v[2][4]=7，当停靠站点为3时，其中v[1][3]+v[3][4]=8。原v[1][4]=9。取最优解，则v[1][4]=7。1～4的最优停靠站点为2，则设置s[1][4]=2
	i=2，j=5时，停靠站点为3时，其中v[2][3]+v[3][5]=9，当停靠站点为4时，其中v[2][4]+v[4][5]=10。原v[2][5]=11。取最优解，则v[2][5]=9。2~5的最优停靠站点为3，则设置s[2][5]=3
	i=3，j=6时，停靠站点为4时，其中v[3][4]+v[4][6]=11，当停靠站点为5时，其中v[3][5]+v[5][6]=12。原v[3][6]=12。取最优解，则v[3][6]=11。3～6的最优停靠站点为4，则设置s[3][6]=4
当按照四个站点计算完毕，二维数组v的结果为

|站点|1|2|3|4|5|6|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|1|0|2|5|7|15|20|
|2|0|0|3|5|9|18|
|3|0|0|0|3|6|11|
|4|0|0|0|0|5|8|
|5|0|0|0|0|0|6|
|6|0|0|0|0|0|0|

	依次计算5个站点的最优解，其中i，i+1，i+2，i+3，j=i+4，将最优解存储至v[i][j]，i取值范围(1~n-4)
	如果每次计算五个站点，则
	i=1，j=5，停靠站点为2时，其中v[1][2]+v[2][5]=11，当停靠的站点为3时，其中v[1][3]+v[3][5]=11，当停靠站点为4时，其中v[1][4]+v[4][5]=12，原v[1][5]=15。取最优解，则v[1][5]=11。1～5的最优停靠站点为2，则设置s[1][5]=2
	i=2，j=6，停靠站点为3时，其中v[2][3]+v[3][6]=14，当停靠的站点为4时，其中v[2][4]+v[4][6]=13，当停靠站点为5时，其中v[2][5]+v[5][6]=15，原v[2][6]=18。取最优解，则v[2][6]=13。2～6的最优停靠站点为3，则设置s[2][6]=4
当按照5个站点计算完毕，二维数组v的结果为

|站点|1|2|3|4|5|6|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|1|0|2|5|7|11|20|
|2|0|0|3|5|9|13|
|3|0|0|0|3|6|11|
|4|0|0|0|0|5|8|
|5|0|0|0|0|0|6|
|6|0|0|0|0|0|0|

	依次计算6个站点的最优解，其中i，i+1，i+2，i+3，i+4，j=i+4，将最优解存储至v[i][j]，i取之范围(1~n-5)
	如果每次计算5个站点，则
	i=1，j=6，停靠站点为2时.......
	参考上面步骤，最终更新v[1][6]=15，1～6的最优停靠站点为2，则设置s[1][6]=2
当按照6个站带你计算完毕，二维数组v的结果为。

|站点|1|2|3|4|5|6|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|1|0|2|5|7|11|15|
|2|0|0|3|5|9|13|
|3|0|0|0|3|6|11|
|4|0|0|0|0|5|8|
|5|0|0|0|0|0|6|
|6|0|0|0|0|0|0|

其中v[1][6]的值为从站点1到站点6的最小租金话费，话费为15   
最终得到的存放最优停靠站点的二维数组s为

|站点|1|2|3|4|5|6|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|1|0|0|2|2|2|2|
|2|0|0|0|0|3|4|
|3|0|0|0|0|0|4|
|4|0|0|0|0|0|0|
|5|0|0|0|0|0|0|
|6|0|0|0|0|0|0|

	二维数组s中存储的为每个区间的最优停靠点，所以我们可以查看s[1][6]中存放的为2，则表示为从站点1到站点6的最优停靠点为2   
	以此将问题拆分为俩个子问题（1，2）和（2，3，4，5，6）   
	子问题（1，2）读取到s[1][2]为0，表示中间没有最优停靠点   
	子问题（2，3，4，5，6）读取到s[2][6]为4，则表示站点2到站点6中的最优停靠点为4。以此将问题拆分为俩个子问题(2，3，4)和（4，5，6）   
	子问题（2，3，4）读取到s[2][4]为0，表示中间没有最优停靠点   
	子问题（4，5，6）读取到s[4][6]为0，表示中间没有最优停靠点   
通过分析二维数组s，我们最终得到最优的停靠点为1-2-4-6。   

#### 程序实现
	#include <iostream>

	using namespace std;

	const int ms = 1000;
	int r[ms][ms],m[ms][ms],s[ms][ms];
	int n;

	void rent()
	{
	    int i,j,k,d;
	    //乘客从起点开始
	    //依次按照3个站点、4个站点....直到所有站点。
	    for (d=3; d <= n; d++) {
	        for (i=1; i<=n-d+1; i++) {
	            //j为每次计算的临时终点
	            j=i+d-1;
	            //k为中转站点，找出组合中花费最小的，替换二维表中原有的值
	            for (k = i+1; k<j; k++) {
	                int temp;
	                temp = m[i][k] + m[k][j];
	                if (temp < m[i][j]) {
	                    m[i][j] = temp;
	                    //记录从站点i到j的最优停靠点
	                    s[i][j] = k;
	                }
	            }
	        }
	    }
	}
	void print(int i ,int j)
	{
	    if (s[i][j] == 0) {
	        cout << "--" << j;
	        return;
	    }
	    print(i, s[i][j]);
	    print(s[i][j],j);
	}

	int main()
	{
	    int i,j;
	    cout << "请输入站点的个数：";
	    cin >> n;
	    cout << "依次输入各站点之间的租金：";
	    for (i = 1; i<=n; i++) {
	        for (j = i+1; j<=n; j++) {
	            cin >> r[i][j];
	            m[i][j] = r[i][j];
	        }
	    }
	    rent();
	    cout << "花费的最少租金为：" << m[1][n] << endl;
	    cout << "最少租金经过的站点：" << 1;
	    print(1, n);
	    cout << endl;
	    return 0;
	}
#### 运行结果
	请输入站点的个数：6
	依次输入各站点之间的租金：2 6 9 15 20 3 5 11 18 3 6 12 5 8 6
	花费的最少租金为：15
	最少租金经过的站点：1--2--4--6


