# 动态规划
我们在分治法中学习的是将原问题分解为若干个规模较小，形式相同的子问题，子问题之间相互独立，通过求解子问题的解，而后合并子问题的解得到原问题的解。   
但是如果子问题有重叠，不能相互独立，那么如果使用了分治算法，就会重复计算子问题，导致效率及其低下。此时我们就需要动态规划。   
动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干个子问题，自顶向下求解各个子问题，合并子问题求解。动态规划是把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存入表格，再求解大的子问题时，直接从表格中查询小的子问题求解，避免重复计算，从而提高算法效率。

### 动态规划算法要素：
	1、最优子结构。最优子结构性质是指问题的最优解包含子问题的最优解。最优子结构是使用动态规划的基本条件，如果不满足最优子结构，就不可以使用动态规划。
	2、子问题重叠。子问题重叠是在求解的过程中，有大量子问题是重叠的，所以在求解过程中，将子问题的解存储，一遍求解更大问题时直接使用，避免重复计算，提高效率


### 最长公共子序列
如果我们有俩个序列X={x1,x2,x3,x4,x5,x6.....xn}，Y={y1,y2,y3,y4,y5......yn}，需要从X序列中和Y序列中找出一个最长的公共子序列。

#### 算法设计
> 1. 从俩个字符串中找出一个最长的公共子序列，需要对俩个字符串中的左右字符做逐一比对，最终按照顺序找出一个最长的公共子序列。看似优点像分治法，需要将大问题拆分若干个小问题，实则不然，拆分后的子问题彼此之间相互嵌套，所以并不能使用分治法来解决问题。
> 2. 假设俩个字符串str1和str2长度分别为i和j，则使用一个二维数组来记录最长公共序列的长度，在运算结束后，通过倒推的方式将最长子序列推到出来。声明二维数组c[][];
> 3. 初始化二维数组的第一行和第一列均为0
> 4. 循环处理
>> a. i=1，则str1[0]与str2[j-1]比较，其中j=1，2，3，4，5......j-1.  
>> b. 如果str1[0] = str2[j-1]，则c[i][j] = c[i-1][j-1] + 1
>> c. 如果str1[0] ≠ str2[j-1]，则当前公共序列的最长度为c[i-1][j]与c[i][j-1]俩者中较大的值，如：c[i-1][j] >= c[i][j-1]，则c[i][j] = c[i-1][j]。
>> d. i=2，则str1[1]与str2[j-1]比较，其中j=1，2，3，4，5......j-1.  
>> e. 重复b、c步骤
>> f. 直至俩个字符串中所有字符比较完毕，其中c[i][j]中的值即为俩个序列最长公共子序列的长度。
>> g. 通过我们求出的二维数组中的所有值，按照b、c逻辑倒推，求出最长公共子序列。

#### 程序实现
	#include <iostream>
	#include <cstring>

	using namespace std;

	const int N = 100;
	int c[N][N];
	char str1[N],str2[N];
	int len1,len2;

	void LCSL()
	{
	    int i,j;
	    for (i = 1; i <= len1; i++) {
	        for (j = 1; j <= len2; j++) {
	            if (str1[i - 1] == str2[j - 1]) {
	                c[i][j] = c[i-1][j-1] + 1;
	            } else {
	                if (c[i][j -1] >= c[i-1][j]) {
	                    c[i][j] = c[i][j-1];
	                }else{
	                    c[i][j] = c[i-1][j];
	                }
	            }
	        }
	    }
	}

	void print(int i,int j)
	{
	    if (i < 0 || j < 0) {
	        return;
	    }
	    if (c[i][j] == c[i-1][j-1]) {
	        print(i - 1, j - 1);
	        return;
	    }
	    if (c[i][j-1] == c[i-1][j] && c[i-1][j-1] == c[i][j-1]) {
	        print(i - 1, j - 1);
	        cout << str1[i - 1];
	        return;
	    }
	    if (c[i][j-1] >= c[i-1][j]) {
	        print(i,j-1);
	    }
	    if (c[i-1][j] > c[i][j-1]) {
	        print(i-1,j);
	    }
	}


	int main()
	{
	    int i,j;
	    cout << "输入第一个字符串S1" << endl;
	    cin >> str1;
	    cout << "输入第二个字符串S2" << endl;;
	    cin >> str2;
	    
	    len1 = strlen(str1);
	    len2 = strlen(str2);
	    
	    for (i = 0; i <= len1; i++) {
	        c[i][0] = 0;
	    }
	    for (j = 0;j <= len2; j++) {
	        c[0][j] = 0;
	    }
	    LCSL();
	    
	    cout << "    ";
	    for (j = 0; j <= len2; j++) {
	        cout << str2[j] << " ";
	    }
	    cout << endl;
	    for (i = 0; i <= len1;i++) {
	        if (i > 0) {
	            cout << str1[i - 1] << " ";
	        }else{
	            cout << "  ";
	        }
	        
	        for (j = 0; j <= len2; j++) {
	            cout << c[i][j] << " ";
	        }
	        cout << endl;
	    }
	    
	    cout << "-------------------" << endl;
	    
	    print(len1,len2);
	    cout << endl;
	    return 0;
	}

#### 运行结果
```
输入第一个字符串S1
abcdefhtc
输入第二个字符串S2
acdeftbc
    a c d e f t b c 
  0 0 0 0 0 0 0 0 0 
a 0 1 1 1 1 1 1 1 1 
b 0 1 1 1 1 1 1 2 2 
c 0 1 2 2 2 2 2 2 3 
d 0 1 2 3 3 3 3 3 3 
e 0 1 2 3 4 4 4 4 4 
f 0 1 2 3 4 5 5 5 5 
h 0 1 2 3 4 5 5 5 5 
t 0 1 2 3 4 5 6 6 6 
c 0 1 2 3 4 5 6 6 7 
-------------------
acdeftc
```
#### 算法分析
> 1. 我们打印出了用以记录最长公共子序列长度的二维表，对照二维表我们可以反向分析算法设计中的诸多问题。   
> 2. 二维表的列的下标对应str1数组的下标，行的下标对应str2数组的下标。   
> 3. 使用str1中的每个字符与str2的字符比对，如str1中的a与str2中比对，第一个字符相等，所以str1中的a同str2中的a的公共子序列的长度为1.继续与str2的其他字符比对，知道完全比对完，最终c[1][j]=1。表示字符a与str2的公共子序列的长度为1。
> 4. 我们继续用str1的第二个字符b，与str2比对，在j=7时于str2的b相等，所以str1中的ab与str2的公共子序列的长度为2。
> 5. 同理，我们继续用str1的第三个字符c，与str2比对，在j=2时与str2的c相等，所以str中的abc与str2中的ac公共子序列的长度为2。直至j=8时，str1中的abc与str2字符串的公共子序列的长度为3
> 6. 重复执行，直至str1中的所有字符与str2比对完毕，则在c[i][j]处保存的即为俩个字符串的公共子序列的长度。
> 7. 通过二维数据表，算法设计中的b、c俩个数据处理方式的逆推，即可求出最长公共子序列

### 编辑距离
我们经常会听到DNA亲子鉴定，但是具体是如何鉴定的我们完全不明白什么原理，人类的DBA由4个基本字母{A,C,G,T}构成，包含30多亿个字符。我们经常在电视上看到DNA鉴定报告由相似度99.99%，哪怕是0.01%也意味着300万个位置不同，那么面对如此庞大的数据量，如何判断俩个基因的相似度呢？生物学给出一种编辑距离的概念。
如何理解编辑距离呢？
```
	在信息论、语言学和计算领域，Levenshtein Distance 是用来度量两个序列相似程度的指标。
	通俗地来讲，编辑距离指的是在两个单词w1,w2之间，由其中一个单词w1转换为另一个单词w2所需要的最少单字符编辑操作次数。
	这里定义了编辑操作有三种：插入、删除、替换
	如：sister和system这俩个单词，由sister转换为system需要的最少单字符编辑操作
		i替换为y
		r替换为m
	一共俩次操作，所有sister和system的编辑距离为2.
	
```
#### 算法分析
> 1. 因需要比对俩个字符str1和str2，我们用一个二维数组来记录编辑距离dis[][]，其二维数组的行和列为len(str2)+1、列为len(str1)+1，如：数组的大小为dis[i][j]，其中i=len(str1)+1 ，j=len(str2)+1
> 2. 初始化这个二维数组，行的每个数值为0，1，2，3......len(str2)，列的数值为0，1，2，3....len(str1)，行和列分别对应俩个字符，如： 

| | |s|y|s|t|e|m|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
| |0|1|2|3|4|5|6|
|s|1| | | | | | |
|i|2| | | | | | |
|s|3| | | | | | |
|t|4| | | | | | |
|e|5| | | | | | |
|r|6| | | | | | |

> 当i=1时，与str1中的第一个字符s与str2做一次比对，如果字符相等，则dis[i][j]=0,否则dis[i][j]=1，按照递归公式d[i][j] = min{dis[i-1][j]+1,dis[i][j-1]+1,dis[i-1][j-1]+dis[i][j]}，
那么当str1的第一个字符，与str2中的每个字符比对时，得到的数值为，0，1，2，3，4，5。如：

| | |s|y|s|t|e|m|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
| |0|1|2|3|4|5|6|
|s|1|0|1|2|3|4|5|
|i|2| | | | | | |
|s|3| | | | | | |
|t|4| | | | | | |
|e|5| | | | | | |
|r|6| | | | | | |

> 当i=2时，与str2中的第二个字符i与str2座一次比对，则得到的对应的数值为：1，1，2，3，4，5。继而用str1中的每个字符进行比对。

| | |s|y|s|t|e|m|
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
| |0|1|2|3|4|5|6|
|s|1|0|1|2|3|4|5|
|i|2|1|1|2|3|4|5|
|s|3|2|2|1|2|3|4|
|t|4|3|3|2|1|2|3|
|e|5|4|4|3|2|1|2|
|r|6|5|5|4|3|2|2|

> 运算完毕后，dis[len1][len2]值为俩个字符的编辑距离   

#### 程序实现
	#include <iostream>
	#include <cstring>

	using namespace std;

	const int N = 1000;

	char str1[N],str2[N];
	int dis[N][N];

	int min(int a,int b)
	{
	    return a>b?b:a;
	}

	int editDistance(char *str1,char *str2)
	{
	    int len1 = strlen(str1);
	    int len2 = strlen(str2);
	    for (int i = 0; i <= len1; i++) {
	        dis[i][0] = i;
	    }
	    cout << endl << "   " ;
	    for (int j = 0; j <= len2; j++) {
	        cout << " " << str2[j];
	    }
	    cout << endl << " " ;
	    for (int j = 0; j <= len2; j++) {
	        dis[0][j] = j;
	        cout << " " << dis[0][j];
	    }
	    for (int i = 1; i <= len1; i++) {
	        for (int j = 1; j <= len2; j++) {
	            int dif;
	            if (str1[i-1] == str2[j-1]) {
	                dif = 0;
	            } else {
	                dif = 1;
	            }
	            int temp = min(dis[i][j-1] + 1,dis[i-1][j] + 1);
	            dis[i][j] = min(temp,dis[i-1][j-1] + dif);
	        }
	        cout << endl << str1[i-1] << " " << i << " ";
	        for(int j = 1;j<=len2;j++){
	            cout << dis[i][j] << " ";
	        }
	    }
	    return dis[len1][len2];
	}
	int main ()
	{
	    cout << "输入第一个字符串" << endl;
	    cin >> str1;
	    cout << "输入第二个字符串" << endl;
	    cin >> str2;
	    int distance = editDistance(str1, str2);
	    cout << endl << str1 << "和" << str2 << "的编辑距离是：" << distance << endl;
	    return 0;
	}
#### 运行结果1
	输入第一个字符串
	sistem
	输入第二个字符串
	system
	    s y s t e m 
	  0 1 2 3 4 5 6
	s 1 0 1 2 3 4 5 
	i 2 1 1 2 3 4 5 
	s 3 2 2 1 2 3 4 
	t 4 3 3 2 1 2 3 
	e 5 4 4 3 2 1 2 
	r 6 5 5 4 3 2 2 
	sistem和system的编辑距离是：2

#### 运行结果2
	输入第一个字符串
	annie
	输入第二个字符串
	anyone
	    a n y o n e 
	  0 1 2 3 4 5 6
	a 1 0 1 2 3 4 5 
	n 2 1 0 1 2 3 4 
	n 3 2 1 1 2 2 3 
	i 4 3 2 2 2 3 3 
	e 5 4 3 3 3 3 3 
	annie和anyone的编辑距离是：3

### 游艇租凭
游艇俱乐部在长江上设置了N个游艇出租站，游艇可以在这些租用游艇，在下游的任何一个点归还游艇，每一站的游艇租金固定，现在要求出游艇出租站1到出租站n所需的最少的租金。
```
从起点到终点，每一站都有不同的租金，那么从起点到终点的最优解是否包含1～n的最优解，答案是肯定的。
假如我们在第K个站点停靠会得到最优解，那么我们就可以将问题分为俩部分1~k、k～N，其中俩个子问题均包含子结构的最优解。
从第一站开始，逐层增加


```

#### 算法分析

