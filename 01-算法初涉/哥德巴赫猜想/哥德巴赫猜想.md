#什么是哥德巴赫猜想
哥德巴赫猜想：任意大于2的偶数，都可以表示成俩个素数之和

-----
验证2000以内的大于2的偶数都能分解为俩个素数之和

###问题分析
从大于2的偶数项至2000，循环处理，每循环一项将数字拆分为俩个数字，验证俩数字是否为素数，如   
i = 4 拆分为 (2,2)(3,1)   
i = 6 拆分为 (2,4)(3,3)(4,2)(5,1)   
i = 8 拆分为 (2,6)(3,5)(4,4)(5,3)(6,2)(7,1)   
i = 10 拆分为 (2,8)(3,7)(4,6)(5,5)(6,4)(7,3)(8,2)(9,1)   
......   
每个偶数都可拆分为若干组可以相加等于该偶数的数字，从若干组数据中找出一组俩个数字均为素数则证明当前偶数符合哥德巴赫猜想   
当2至2000的所有偶数循环完毕，每个偶数拆分的组合均可寻找出一组素数组合，则证明哥德巴赫猜想   

	//判断当前数字是否为素数
	int is_prime(int i)
	{
	    int j;
	    if (i <= 1) return 0;
	    if (i == 2) return 1;
	    for (j = 2; j <= (int)(sqrt((double)i)); j++) {
	        if (!(i%j)) return 0;
	    }
	    return 1;
	}

	void gold_con()
	{
	    int i ,n;
	    //对大于2小于2000的所有偶数，逐个拆分判断，从4开始
	    for (i = 4; i <= 2000; i += 2) {
	    	//分解当前偶数，分解为n和i-n
	        for (n = 2; n < i; n++) {
	            if (is_prime(n)) {
	                if (is_prime(i - n)) {
	                    cout << i << "=" << n << "+" << i - n << endl;
	                    break;
	                }
	            }
	        }
	        if (i == n) {
	            cout << "证明异常" << endl;
	        }
	    }
	}
我们来分析下上面的代码   
每个数字拆分后都需要调用prime函数，而越大的数字可拆分的组就越多，需要调用prime函数的次数就越多
***
基于调用prime函数过于频繁，而且同一个数字在不同偶数拆分的过程中被重复的调用prime函数验证，极大的增加了时间复杂度，我们需要优化一下算法   
声明一个一个长度为1999的数组，数组的下标1～1998对应存储的数据为当前下标是否为素数   
如此一来我们在验证是否为素数时只需通过下标去访问数组即可得知，时间复杂度降低为O(1)   

	void gold_con()
	{
	    int *prime_arr = new int[1999];
	    for (int i = 2; i < 1998; i++) {
	        prime_arr[i] = is_prime(i);
	    }
	    int i ,n;
	    for (i = 4; i < 2000; i += 2) {
	        for (n = 2; n < i; n++) {
	            if (prime_arr[n]) {
	                if (prime_arr[i - n]) {
	                    cout << i << "=" << n << "+" << i - n << endl;
	                    break;
	                }
	            }
	        }
	        if (i == n) {
	            cout << "error" << endl;
	        }
	    }
	}
	
相比第一个算法，我们增加了一个长度1999的数组，用于存储对应下标是否为素数，虽空间复杂度增加，但是时间复杂度已然降低。所有数字只需计算一次是否为素数，且每个数字验证的过程总时间复杂度为O(1)。      
***   
我们再来分析一下问题，我们需要验证的是：2000以内的大于2的偶数都能分解为俩个素数之和   
而2000以内的素数我们可以很轻易就全部找出，那么我们是否可以在拆分时就先设定第一个数字为素数，而无需每次都从2开始逐个增加。   

	void gold_con()
	{
	    int *prime_arr = new int[302];
	    int *data_arr = new int[1999];
	    int index = 0;
	    for (int i = 2; i<1998; i++) {
	        if (is_prime(i)) {
	            data_arr[i] = 1;
	            prime_arr[index++] = i;
	        }else{
	            data_arr[i] = 0;
	        }
	    }
	    for (int i = 4; i< 2000; i += 2) {
	        int j;
	        bool flag = true;
	        for (j = 0; prime_arr[j] < i; j++) {
	            if (data_arr[i - prime_arr[j]]) {
	                flag = false;
	                cout << i << "=" << prime_arr[j] << "+" << i-prime_arr[j] << endl;
	                break;
	            }
	        }
	        if (flag) {
	            cout << "error" << endl;
	        }
	    }
	}

相比上一个算法，我们再次增加了一个302的数组，用以存储2000以内的所有素数     
因存储的素数为有序的数组，逐个取出后用以拆分，只需验证拆分后的另一个数字为素数，则验证通过   




