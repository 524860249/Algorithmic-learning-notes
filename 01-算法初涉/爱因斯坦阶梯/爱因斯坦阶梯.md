#什么是爱因斯坦阶梯
爱因斯坦家有条阶梯，阶梯数量未知。但如果每步迈出2个阶梯最后余1个阶梯，每步迈出3步最后余2个阶梯，每步迈出5个阶梯最后余4个阶梯，每步迈出6个阶梯最后余5个阶梯，每次迈出7个阶梯最后则一阶不剩，那么请问爱因斯家的阶梯究竟有多少阶？  

###递推公式
假设阶梯数量为n，则  
n mod 2 = 1  
n mod 3 = 2  
n mod 5 = 4  
n mod 6 = 5  
n mod 7 = 0  

###算法实现
从1开始循环递增的逐个结算是否满足所有的条件，如果条件满足，则结束循环  

	int ein_ladder()
	{
	    int n = 1;
	    while(!(n %2 == 1 && n % 3 == 2 && n % 5 == 4 && n % 6 == 5 && n % 7 == 0))
	    {
	        n++;
	    }
	    return n;
	}

我们在运行之初无法知道while循环究竟会循环多少次  
但是我们逐一去计算每一个数字是否满足确实有点蠢  
***
既然每次踏出的阶梯数为7时，在最后刚好一阶不剩，那么阶梯数必然是7的倍数  
基于分析，我们优化代码如下  

	int ein_ladder()
	{
	    int n = 7;
	    while(!(n %2 == 1 && n % 3 == 2 && n % 5 == 4 && n % 6 == 5 && n % 7 == 0))
	    {
	        n += 7;
	    }
	    return n;
	}

如此一来，程序循环的步长由1变为7，则允许次数必然是原来的1/7  
***
那么我们已经将算法复杂度变为原来的1/7，我们是否可以再次降低算法的复杂度呢  
我们再次分析一些原题，当每步迈出的步数为2、3、5、6时，最后刚好剩余的阶数为1、2、4、5，刚好都是差一步即可刚刚跨完  
那么结果必然是2、3、5、6的公倍数-1，且刚好是7的倍数  
基于分析，我们优化代码如下  

	int ein_ladder()
	{
		//我们先求出2、3、5、6的最小公倍数
		//因6为2和3的最小公倍数，那么我们只需求出5和6的最小公倍数即可
	    int com_mul = 6;
	    while(!(com_mul % 5 == 0))
	    {
	        com_mul += 6;
	    }
	    //初始化结果为最小公倍数-1
	    int result = com_mul - 1;
	    while(!(result % 7 == 0))
	    {
	        result += com_mul;
	    }
	    cout << result << endl;
	    return com_mul;
	}

经过我们的优化，我们显然可以看出，相比较循环比较7的倍数求出结果，复杂度再次降低  


